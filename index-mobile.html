<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Castle Wars: Mobile</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      width: 100vw;
      height: 100vh;
      background-color: #000000;
      overflow: hidden;
      position: fixed;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
    }
    
    #game {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Hide ALL desktop UI elements */
    #gameUI, #bottom-ui-panel, .game-ui-panel, #inventory-panel, #party-panel, #chat-container {
      display: none !important;
    }
    
    /* Mobile UI overlay */
    #mobile-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
    
    #mobile-overlay.active {
      display: block;
    }
    
    /* Top stats bar */
    #mobile-stats {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0.2));
      padding: 10px;
      padding-top: env(safe-area-inset-top, 10px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .stat-group {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 25px;
      font-size: 14px;
      color: white;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .stat-icon {
      font-size: 18px;
    }
    
    #health-bar {
      width: 80px;
      height: 8px;
      background: rgba(255,255,255,0.3);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    #health-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ff8e53);
      transition: width 0.3s ease;
      width: 100%;
      border-radius: 3px;
    }
    
    /* Dual joystick system */
    .joystick-container {
      position: absolute;
      width: 140px;
      height: 140px;
      pointer-events: auto;
    }
    
    #movement-joystick {
      left: 20px;
      bottom: 20px;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    }
    
    #aim-joystick {
      right: 20px;
      bottom: 20px;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
      border: 3px solid rgba(255,255,255,0.4);
      border-radius: 50%;
      box-shadow: 0 0 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(255,255,255,0.1);
    }
    
    .joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.6));
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      pointer-events: none;
      border: 2px solid rgba(255,255,255,0.8);
    }
    
    /* Center action buttons */
    #center-actions {
      position: absolute;
      left: 50%;
      bottom: 40px;
      bottom: calc(40px + env(safe-area-inset-bottom, 0px));
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }
    
    .center-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      border: 3px solid;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .center-btn:active {
      transform: scale(0.9);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    }
    
    #weapon-btn {
      background: rgba(255, 193, 7, 0.8);
      border-color: #ffc107;
      color: #fff;
    }
    
    #build-btn {
      background: rgba(40, 167, 69, 0.8);
      border-color: #28a745;
      color: white;
    }
    
    #build-btn.active {
      background: rgba(220, 53, 69, 0.8);
      border-color: #dc3545;
    }
    
    /* Build mode indicator */
    #build-mode-indicator {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 16px;
      border: 2px solid #dc3545;
      box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
      display: none;
      pointer-events: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    /* Weapon interface */
    #weapon-interface {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      padding: 15px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 15px;
      border: 2px solid #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      pointer-events: auto;
      z-index: 1100;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
    }
    
    .weapon-grid {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .weapon-slot {
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .weapon-slot.selected {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }
    
    .weapon-slot.empty {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.2);
      cursor: default;
    }
    
    .weapon-slot img {
      width: 45px;
      height: 45px;
      object-fit: contain;
      image-rendering: pixelated;
    }
    
    .weapon-number {
      position: absolute;
      top: -5px;
      left: -5px;
      width: 20px;
      height: 20px;
      background: #333;
      border: 2px solid #ffd700;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #ffd700;
      font-weight: bold;
    }
    
    /* Build interface */
    #build-interface {
      position: absolute;
      bottom: 120px;
      right: 20px;
      display: none;
      flex-direction: column;
      gap: 10px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 15px;
      border: 2px solid #28a745;
      box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
      pointer-events: auto;
      z-index: 1100;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      max-height: 300px;
      overflow-y: auto;
    }
    
    .build-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    
    .build-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .build-slot.selected {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .build-slot.delete {
      background: rgba(220, 53, 69, 0.7);
      border-color: #dc3545;
    }
    
    /* Quick actions */
    #quick-actions {
      position: absolute;
      top: 80px;
      right: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }
    
    .quick-btn {
      width: 50px;
      height: 50px;
      background: rgba(0,0,0,0.8);
      border: 2px solid rgba(255,255,255,0.4);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      color: white;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .quick-btn:active {
      background: rgba(255,255,255,0.2);
      transform: scale(0.95);
    }
    
    /* Responsive adjustments */
    @media screen and (orientation: landscape) and (max-height: 500px) {
      #mobile-stats { padding: 5px; }
      .stat-group { font-size: 12px; padding: 6px 10px; }
      .joystick-container { width: 120px; height: 120px; }
      .center-btn { width: 50px; height: 50px; font-size: 20px; }
      #center-actions { bottom: 20px; }
      #build-mode-indicator { top: 60px; font-size: 14px; padding: 8px 16px; }
    }
    
    /* iPhone X+ safe areas */
    @supports (padding: max(0px)) {
      #mobile-stats {
        padding-left: max(10px, env(safe-area-inset-left));
        padding-right: max(10px, env(safe-area-inset-right));
      }
      #movement-joystick { left: max(20px, env(safe-area-inset-left)); }
      #aim-joystick { right: max(20px, env(safe-area-inset-right)); }
      #quick-actions { right: max(15px, env(safe-area-inset-right)); }
      #build-interface { right: max(20px, env(safe-area-inset-right)); }
    }
  </style>
</head>
<body>
  <div id="game"></div>
  
  <div id="mobile-overlay">
    <!-- Top stats bar -->
    <div id="mobile-stats">
      <div class="stat-group">
        <span class="stat-icon">❤️</span>
        <div id="health-bar">
          <div id="health-fill"></div>
        </div>
        <span id="health-text">100</span>
      </div>
      
      <div class="stat-group">
        <span class="stat-icon">🔫</span>
        <span id="weapon-name">PISTOL</span>
      </div>
      
      <div class="stat-group">
        <span class="stat-icon">🔵</span>
        <span id="ammo-count">12/12</span>
      </div>
    </div>
    
    <!-- Build mode indicator -->
    <div id="build-mode-indicator">🏗️ BUILD MODE</div>
    
    <!-- Movement joystick -->
    <div id="movement-joystick" class="joystick-container">
      <div class="joystick-base"></div>
      <div class="joystick-stick"></div>
    </div>
    
    <!-- Aim joystick -->
    <div id="aim-joystick" class="joystick-container">
      <div class="joystick-base"></div>
      <div class="joystick-stick"></div>
    </div>
    
    <!-- Center action buttons -->
    <div id="center-actions">
      <div id="weapon-btn" class="center-btn">🔫</div>
      <div id="build-btn" class="center-btn">🏗️</div>
    </div>
    
    <!-- Quick actions -->
    <div id="quick-actions">
      <div id="inventory-btn" class="quick-btn">🎒</div>
      <div id="chat-btn" class="quick-btn">💬</div>
    </div>
    
    <!-- Weapon interface -->
    <div id="weapon-interface">
      <div class="weapon-grid" id="weaponGrid">
        <!-- Weapons will be dynamically populated -->
      </div>
      <div style="text-align: center; margin-top: 10px;">
        <button id="delete-weapon-btn" style="background: rgba(220,53,69,0.7); border: none; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; margin-right: 10px; opacity: 0.5;" disabled>Delete</button>
        <button id="close-weapon-btn" style="background: rgba(40,167,69,0.7); border: none; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px;">Close</button>
      </div>
    </div>
    
    <!-- Build interface -->
    <div id="build-interface">
      <div class="build-grid" id="buildGrid">
        <div class="build-slot" data-type="wall">
          <img src="/assets/blocks/wall.png" alt="Wall" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="door">
          <img src="/assets/blocks/door.png" alt="Door" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="tunnel">
          <img src="/assets/blocks/tunnel.png" alt="Tunnel" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="castle_tower">
          <img src="/assets/blocks/castle_tower.png" alt="Castle Tower" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="wood">
          <img src="/assets/blocks/wood.png" alt="Wood" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="gold">
          <img src="/assets/blocks/gold.png" alt="Gold" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="roof">
          <img src="/assets/blocks/roof.png" alt="Roof" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot" data-type="brick">
          <img src="/assets/blocks/brick.png" alt="Brick" style="width: 32px; height: 32px; image-rendering: pixelated;">
        </div>
        <div class="build-slot delete" data-type="delete">❌</div>
      </div>
    </div>
  </div>
  
  <script type="module">
    // Enhanced Mobile Controls with dual joysticks
    class EnhancedMobileControls {
      constructor() {
        this.movement = { x: 0, y: 0 };
        this.aiming = { x: 0, y: 0, angle: 0 };
        this.buildMode = false;
        this.selectedWeapon = 'pistol';
        this.selectedBlock = 'wall';
        this.deleteMode = false;
        this.weaponShopOpen = false;
        
        // Touch tracking for multi-touch
        this.activeTouches = new Map();
        this.maxJoystickDistance = 50;
        
        this.init();
      }
      
      init() {
        this.setupJoysticks();
        this.setupActionButtons();
        this.setupWeaponInterface();
        this.setupBuildInterface();
        this.setupQuickActions();
        this.startUpdateLoop();
      }
      
      setupJoysticks() {
        this.setupJoystick('movement-joystick', 'movement');
        this.setupJoystick('aim-joystick', 'aiming');
      }
      
      setupJoystick(containerId, type) {
        const container = document.getElementById(containerId);
        const stick = container.querySelector('.joystick-stick');
        
        const handleStart = (e) => {
          e.preventDefault();
          const touch = e.touches ? e.touches[0] : e;
          
          // Store this touch ID for this joystick
          const touchId = touch.identifier || 'mouse';
          if (this.activeTouches.has(touchId)) return;
          
          const rect = container.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          this.activeTouches.set(touchId, {
            joystick: type,
            startX: centerX,
            startY: centerY,
            container: container,
            stick: stick
          });
        };
        
        const handleMove = (e) => {
          e.preventDefault();
          
          // Handle all touches
          for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            const touchData = this.activeTouches.get(touch.identifier);
            
            if (!touchData || touchData.joystick !== type) continue;
            
            const rect = touchData.container.getBoundingClientRect();
          const currentX = touch.clientX - rect.left;
          const currentY = touch.clientY - rect.top;
          
            let deltaX = currentX - touchData.startX;
            let deltaY = currentY - touchData.startY;
          
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          
          if (distance > this.maxJoystickDistance) {
            const angle = Math.atan2(deltaY, deltaX);
            deltaX = Math.cos(angle) * this.maxJoystickDistance;
            deltaY = Math.sin(angle) * this.maxJoystickDistance;
          }
          
            touchData.stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            
            const normalizedX = deltaX / this.maxJoystickDistance;
            const normalizedY = deltaY / this.maxJoystickDistance;
            
            if (type === 'movement') {
              this.movement.x = normalizedX;
              this.movement.y = normalizedY;
            } else if (type === 'aiming') {
              this.aiming.x = normalizedX;
              this.aiming.y = normalizedY;
              if (distance > 10) { // Only update angle if moved significantly
                this.aiming.angle = Math.atan2(deltaY, deltaX);
              }
            }
          }
        };
        
        const handleEnd = (e) => {
          // Handle ended touches
          for (const changedTouch of e.changedTouches) {
            const touchData = this.activeTouches.get(changedTouch.identifier);
            if (touchData && touchData.joystick === type) {
              touchData.stick.style.transform = 'translate(0, 0)';
              
              if (type === 'movement') {
          this.movement = { x: 0, y: 0 };
              } else if (type === 'aiming') {
                this.aiming.x = 0;
                this.aiming.y = 0;
              }
              
              this.activeTouches.delete(changedTouch.identifier);
            }
          }
        };
        
        container.addEventListener('touchstart', handleStart, { passive: false });
        container.addEventListener('touchmove', handleMove, { passive: false });
        container.addEventListener('touchend', handleEnd, { passive: false });
        container.addEventListener('touchcancel', handleEnd, { passive: false });
      }
      
      setupActionButtons() {
        // Weapon button
        document.getElementById('weapon-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.toggleWeaponInterface();
        });
        
        // Build button
        document.getElementById('build-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.toggleBuildMode();
        });
      }
      
      setupWeaponInterface() {
        this.refreshWeaponInterface();
        
        // Close button listener
        document.getElementById('close-weapon-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.hideWeaponInterface();
        });
        
        // Delete weapon button listener
        document.getElementById('delete-weapon-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.deleteSelectedWeapon();
        });
      }
      
      refreshWeaponInterface() {
        const weaponGrid = document.getElementById('weaponGrid');
        weaponGrid.innerHTML = '';
        
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          const weapons = player.weaponTypes || [];
          
          // Show up to 5 weapon slots
          for (let i = 0; i < 5; i++) {
            const slot = document.createElement('div');
            slot.className = 'weapon-slot';
            slot.dataset.index = i;
            
            if (i < weapons.length) {
              const weaponType = weapons[i];
              const weaponSprite = this.getWeaponSprite(weaponType);
              
              if (weaponType === this.selectedWeapon) {
                slot.classList.add('selected');
              }
              
              const img = document.createElement('img');
              img.src = `/assets/weapons/${weaponSprite}.png`;
              img.alt = weaponType;
              img.onerror = () => {
                slot.innerHTML = `<span style="font-size: 16px;">${weaponType.substr(0,3)}</span>`;
              };
              
              const number = document.createElement('div');
              number.className = 'weapon-number';
              number.textContent = (i + 1).toString();
              
              slot.appendChild(img);
              slot.appendChild(number);
              
              slot.addEventListener('touchstart', (e) => {
          e.preventDefault();
                this.selectWeapon(weaponType, i);
                this.hideWeaponInterface();
              });
            } else {
              // Empty slot
              slot.classList.add('empty');
              slot.innerHTML = `<span style="font-size: 24px; color: rgba(255,255,255,0.3);">+</span>`;
              
              const number = document.createElement('div');
              number.className = 'weapon-number';
              number.textContent = (i + 1).toString();
              slot.appendChild(number);
            }
            
            weaponGrid.appendChild(slot);
          }
        }
      }
      
      getWeaponSprite(weaponType) {
        const spriteMap = {
          'pistol': 'Orange_pistol',
          'shotgun': 'shotgun',
          'rifle': 'rifle',
          'sniper': 'sniper',
          'tomatogun': 'tomatogun',
          'triangun': 'triangun',
          'minigun': 'minigun'
        };
        return spriteMap[weaponType] || 'pistol';
      }
      
      deleteSelectedWeapon() {
        if (this.selectedWeapon === 'pistol') {
          alert('Cannot delete the pistol!');
          return;
        }
        
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          const weapons = player.weaponTypes || [];
          const index = weapons.indexOf(this.selectedWeapon);
          
          if (index > 0) { // Don't delete pistol (index 0)
            weapons.splice(index, 1);
            if (player.weaponAmmo && player.weaponAmmo[this.selectedWeapon]) {
              delete player.weaponAmmo[this.selectedWeapon];
            }
            
            // Switch to pistol
            this.selectedWeapon = 'pistol';
            if (player.weapon) {
              player.weapon.type = 'pistol';
              player.currentWeapon = 0;
            }
            
            this.refreshWeaponInterface();
          }
        }
      }
      
      addWeaponFromShop(weaponType) {
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          const weapons = player.weaponTypes || [];
          
          // Check if weapon already exists
          if (weapons.includes(weaponType)) {
            this.selectedWeapon = weaponType;
            return;
          }
          
          // Add weapon, replace 5th slot if full
          if (weapons.length >= 5) {
            // Replace the 5th weapon
            weapons[4] = weaponType;
            if (player.weaponAmmo && player.weaponAmmo[weapons[4]]) {
              delete player.weaponAmmo[weapons[4]];
            }
          } else {
            // Add to empty slot
            weapons.push(weaponType);
          }
          
          // Switch to new weapon
          this.selectedWeapon = weaponType;
          const newIndex = weapons.indexOf(weaponType);
          if (player.weapon) {
            player.weapon.type = weaponType;
            player.currentWeapon = newIndex;
          }
          
          this.refreshWeaponInterface();
        }
      }
      
      setupBuildInterface() {
        const buildSlots = document.querySelectorAll('.build-slot');
        
        buildSlots.forEach(slot => {
          slot.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const type = slot.dataset.type;
            
            if (type === 'delete') {
              this.deleteMode = !this.deleteMode;
              slot.style.background = this.deleteMode ? 
                'rgba(220, 53, 69, 0.9)' : 'rgba(220, 53, 69, 0.7)';
              this.clearBlockSelection();
            } else {
              this.selectBlock(type);
              this.deleteMode = false;
              document.querySelector('.build-slot.delete').style.background = 'rgba(220, 53, 69, 0.7)';
            }
          });
        });
      }
      
      setupQuickActions() {
        document.getElementById('inventory-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (window.gameScene && window.gameScene.inventoryUI) {
            window.gameScene.inventoryUI.toggle();
          }
        });
        
        document.getElementById('chat-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.showMobileChat();
        });
      }
      
      selectWeapon(weaponType, index) {
        this.selectedWeapon = weaponType;
        
        // Update visual selection
        document.querySelectorAll('.weapon-slot').forEach(slot => {
          slot.classList.remove('selected');
        });
        
        // Select the weapon slot
        const weaponSlots = document.querySelectorAll('.weapon-slot');
        if (weaponSlots[index]) {
          weaponSlots[index].classList.add('selected');
        }
        
        // Switch weapon in game
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          if (player.weaponTypes && player.weaponTypes.includes(weaponType)) {
            const weaponIndex = player.weaponTypes.indexOf(weaponType);
            if (weaponIndex !== -1) {
              player.switchWeapon(weaponIndex);
            }
          }
        }
        
        // Update display
        document.getElementById('weapon-name').textContent = weaponType.toUpperCase();
        
        // Update delete button
        const deleteBtn = document.getElementById('delete-weapon-btn');
        if (weaponType === 'pistol') {
          deleteBtn.disabled = true;
          deleteBtn.style.opacity = '0.5';
        } else {
          deleteBtn.disabled = false;
          deleteBtn.style.opacity = '1';
        }
      }
      
      selectBlock(blockType) {
        this.selectedBlock = blockType;
        this.deleteMode = false;
        
        // Update visual selection
        document.querySelectorAll('.build-slot').forEach(slot => {
          slot.classList.remove('selected');
        });
        
        const selectedSlot = document.querySelector(`[data-type="${blockType}"]`);
        if (selectedSlot) {
          selectedSlot.classList.add('selected');
        }
        
        // Set in game scene
        if (window.gameScene && window.gameScene.setSelectedBuilding) {
          window.gameScene.setSelectedBuilding(blockType);
        }
      }
      
      clearBlockSelection() {
        document.querySelectorAll('.build-slot').forEach(slot => {
          slot.classList.remove('selected');
        });
      }
      
      toggleWeaponInterface() {
        const weaponInterface = document.getElementById('weapon-interface');
        const buildInterface = document.getElementById('build-interface');
        
        if (weaponInterface.style.display === 'block') {
          this.hideWeaponInterface();
        } else {
          this.refreshWeaponInterface(); // Refresh when opening
          weaponInterface.style.display = 'block';
          buildInterface.style.display = 'none'; // Close build interface
        }
      }
      
      hideWeaponInterface() {
        document.getElementById('weapon-interface').style.display = 'none';
      }
      
      toggleBuildMode() {
        this.buildMode = !this.buildMode;
        
        const buildBtn = document.getElementById('build-btn');
        const buildInterface = document.getElementById('build-interface');
        const weaponInterface = document.getElementById('weapon-interface');
        const indicator = document.getElementById('build-mode-indicator');
        
        if (this.buildMode) {
          buildBtn.classList.add('active');
          buildBtn.innerHTML = '❌';
          buildInterface.style.display = 'flex';
          weaponInterface.style.display = 'none'; // Close weapon interface
          indicator.style.display = 'block';
          this.selectBlock('wall'); // Default selection
        } else {
          buildBtn.classList.remove('active');
          buildBtn.innerHTML = '🏗️';
          buildInterface.style.display = 'none';
          indicator.style.display = 'none';
        }
        
        // Toggle build mode in game
        if (window.gameScene && window.gameScene.toggleBuildMode) {
          window.gameScene.toggleBuildMode();
        }
      }
      
      showMobileChat() {
        // Implementation for mobile chat (similar to previous version)
        console.log('Mobile chat not yet implemented');
      }
      
              startUpdateLoop() {
        setInterval(() => {
          if (window.gameScene && window.gameScene.playerSprite) {
            const player = window.gameScene.playerSprite;
            
            // Update health
            const healthPercent = Math.max(0, Math.min(100, (player.health / player.maxHealth) * 100));
            document.getElementById('health-fill').style.width = healthPercent + '%';
            document.getElementById('health-text').textContent = Math.ceil(player.health);
            
            // Update weapon display
            const weaponName = player.weapon ? player.weapon.type.toUpperCase() : 'FIST';
            document.getElementById('weapon-name').textContent = weaponName;
            
            // Update ammo
            let ammoDisplay = '∞';
            if (player.weapon && player.weapon.currentAmmo !== undefined && player.weapon.currentAmmo !== -1) {
              const current = player.weapon.currentAmmo;
              const max = player.weapon.magazineSize || 30;
              ammoDisplay = player.weapon.isReloading ? 'RELOAD' : `${current}/${max}`;
            }
            document.getElementById('ammo-count').textContent = ammoDisplay;
            
            // Check if in weapon shop
            this.checkWeaponShop(player);
          }
              }, 100);
            }
      
      checkWeaponShop(player) {
        // Weapon shop coordinates (same as desktop version)
        const shopX = 300;
        const shopY = 1650;
        const shopWidth = 400;
        const shopHeight = 400;
        
        if (player.x >= shopX && player.x <= shopX + shopWidth &&
            player.y >= shopY && player.y <= shopY + shopHeight) {
          
          if (!this.weaponShopOpen) {
            this.weaponShopOpen = true;
            this.showWeaponShop();
          }
        } else {
          if (this.weaponShopOpen) {
            this.weaponShopOpen = false;
            this.hideWeaponShop();
          }
        }
      }
      
      showWeaponShop() {
        // Create weapon shop overlay
        const shopOverlay = document.createElement('div');
        shopOverlay.id = 'weapon-shop-overlay';
        shopOverlay.style.position = 'absolute';
        shopOverlay.style.top = '50%';
        shopOverlay.style.left = '50%';
        shopOverlay.style.transform = 'translate(-50%, -50%)';
        shopOverlay.style.background = 'rgba(0, 0, 0, 0.95)';
        shopOverlay.style.border = '3px solid #ffd700';
        shopOverlay.style.borderRadius = '20px';
        shopOverlay.style.padding = '20px';
        shopOverlay.style.backdropFilter = 'blur(15px)';
        shopOverlay.style.zIndex = '2000';
        shopOverlay.style.color = 'white';
        shopOverlay.style.fontWeight = 'bold';
        shopOverlay.style.textAlign = 'center';
        
        const title = document.createElement('h3');
        title.textContent = '🏪 WEAPON SHOP';
        title.style.color = '#ffd700';
        title.style.marginBottom = '20px';
        title.style.fontSize = '24px';
        shopOverlay.appendChild(title);
        
        const weaponList = [
          { type: 'shotgun', name: 'Shotgun', price: 1500 },
          { type: 'rifle', name: 'Rifle', price: 2000 },
          { type: 'sniper', name: 'Sniper', price: 3000 },
          { type: 'tomatogun', name: 'Tomato Gun', price: 2500 },
          { type: 'triangun', name: 'Triangun', price: 4000 },
          { type: 'minigun', name: 'Minigun', price: 5000 }
        ];
        
        weaponList.forEach(weapon => {
          const weaponBtn = document.createElement('button');
          weaponBtn.textContent = `${weapon.name} - ${weapon.price}🪙`;
          weaponBtn.style.display = 'block';
          weaponBtn.style.width = '100%';
          weaponBtn.style.padding = '10px';
          weaponBtn.style.margin = '5px 0';
          weaponBtn.style.background = 'rgba(255, 215, 0, 0.2)';
          weaponBtn.style.border = '2px solid #ffd700';
          weaponBtn.style.borderRadius = '10px';
          weaponBtn.style.color = 'white';
          weaponBtn.style.cursor = 'pointer';
          weaponBtn.style.fontSize = '16px';
          weaponBtn.style.fontWeight = 'bold';
          
          weaponBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.buyWeapon(weapon.type, weapon.price);
          });
          
          shopOverlay.appendChild(weaponBtn);
        });
        
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.marginTop = '20px';
        closeBtn.style.padding = '10px 20px';
        closeBtn.style.background = 'rgba(220, 53, 69, 0.7)';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '10px';
        closeBtn.style.color = 'white';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontSize = '16px';
        closeBtn.style.fontWeight = 'bold';
        
        closeBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.hideWeaponShop();
        });
        
        shopOverlay.appendChild(closeBtn);
        
        document.getElementById('mobile-overlay').appendChild(shopOverlay);
      }
      
      hideWeaponShop() {
        const shopOverlay = document.getElementById('weapon-shop-overlay');
        if (shopOverlay) {
          shopOverlay.remove();
        }
      }
      
      buyWeapon(weaponType, price) {
          if (window.gameScene && window.gameScene.playerSprite) {
            const player = window.gameScene.playerSprite;
            
          if (player.gold >= price) {
            player.gold -= price;
            this.addWeaponFromShop(weaponType);
            
            // Send purchase to server
            window.gameScene.socket.emit('weaponPurchase', {
              weapon: weaponType,
              cost: price
            });
            
            this.hideWeaponShop();
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.textContent = `Purchased ${weaponType.toUpperCase()}!`;
            successMsg.style.position = 'absolute';
            successMsg.style.top = '20px';
            successMsg.style.left = '50%';
            successMsg.style.transform = 'translateX(-50%)';
            successMsg.style.background = 'rgba(0, 255, 0, 0.8)';
            successMsg.style.color = 'white';
            successMsg.style.padding = '10px 20px';
            successMsg.style.borderRadius = '10px';
            successMsg.style.fontWeight = 'bold';
            successMsg.style.zIndex = '3000';
            
            document.getElementById('mobile-overlay').appendChild(successMsg);
            
            setTimeout(() => {
              successMsg.remove();
            }, 2000);
          } else {
            // Not enough gold
            alert(`Not enough gold! Need ${price} gold.`);
          }
        }
      }
    }
    
    // Initialize enhanced mobile controls
    window.mobileControls = new EnhancedMobileControls();
    
    // Import and setup the game
    import('./js/main.js').then(() => {
      console.log('Enhanced mobile game loaded');
      
      const waitForGame = setInterval(() => {
        if (window.GameScene) {
          clearInterval(waitForGame);
          
          // Override LoginScene
          if (window.LoginScene) {
            const originalLoginCreate = window.LoginScene.prototype.create;
            window.LoginScene.prototype.create = function() {
              originalLoginCreate.call(this);
              document.getElementById('mobile-overlay').classList.remove('active');
            };
          }
          
          // Override GameScene create
          const originalCreate = window.GameScene.prototype.create;
          window.GameScene.prototype.create = function() {
            originalCreate.call(this);
            
            window.gameScene = this;
            document.getElementById('mobile-overlay').classList.add('active');
            
            // Mobile camera adjustments
            const gameSize = this.scale.gameSize;
            this.cameras.main.setViewport(0, 0, gameSize.width, gameSize.height);
            this.cameras.main.setZoom(0.9);
            
            // Hide desktop UI
            setTimeout(() => {
              const uiElements = document.querySelectorAll('#gameUI, .game-ui-panel, #bottom-ui-panel, .ui-panel');
              uiElements.forEach(el => el.style.display = 'none');
              
              const chatContainer = document.getElementById('chat-container');
              if (chatContainer) chatContainer.style.display = 'none';
              
              // Sync weapon interface with player weapons
              if (window.mobileControls) {
                setTimeout(() => {
                  window.mobileControls.refreshWeaponInterface();
                }, 1000);
              }
            }, 100);
          };
          
          // Override update for enhanced mobile controls
          const originalUpdate = window.GameScene.prototype.update;
          window.GameScene.prototype.update = function(time, delta) {
            if (window.mobileControls) {
              const m = window.mobileControls.movement;
              const a = window.mobileControls.aiming;
              
              // Movement controls
              this.cursors.left.isDown = m.x < -0.3;
              this.cursors.right.isDown = m.x > 0.3;
              this.cursors.up.isDown = m.y < -0.3;
              this.cursors.down.isDown = m.y > 0.3;
              this.cursors.space.isDown = m.y < -0.7; // Jump on upward joystick
              
              // Aiming and shooting
              if (this.playerSprite && !this.playerSprite.isDead) {
                // Set aim angle from aim joystick
                if (Math.abs(a.x) > 0.1 || Math.abs(a.y) > 0.1) {
                  this.playerSprite.aimAngle = Phaser.Math.RadToDeg(a.angle);
                  
                  // ONLY shoot if not in build mode
                  if (!window.mobileControls.buildMode) {
                    this.playerSprite.isShooting = true;
                  } else {
                    this.playerSprite.isShooting = false;
                  }
                } else {
                  this.playerSprite.isShooting = false;
                }
                
                // FORCE disable shooting in build mode
                if (window.mobileControls.buildMode) {
                  this.playerSprite.isShooting = false;
                }
              }
            }
            
            originalUpdate.call(this, time, delta);
          };
        }
      }, 100);
    });
    
    // Prevent iOS bounce and handle multi-touch
    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    
    // Prevent context menu on long press
    document.body.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
  </script>
</body>
</html>
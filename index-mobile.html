<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Castle Wars: Mobile</title>
  <link rel="icon" type="image/png" href="/assets/favicon.png">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      width: 100vw;
      height: 100vh;
      background-color: #000000;
      overflow: hidden;
      position: fixed;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
    }
    
    /* Portrait orientation overlay */
    #orientation-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      color: white;
      text-align: center;
      padding: 40px 20px;
      overflow: hidden;
    }
    
    #orientation-overlay::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 10px,
        rgba(255, 224, 102, 0.05) 10px,
        rgba(255, 224, 102, 0.05) 20px
      );
      animation: slideBackground 20s linear infinite;
      z-index: -1;
    }
    
    @keyframes slideBackground {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }
    
    @media screen and (orientation: portrait) {
      #orientation-overlay {
        display: flex !important;
      }
      
      #mobile-overlay {
        display: none !important;
      }
      
      #game {
        display: none !important;
      }
    }
    
    .rotate-icon {
      font-size: 80px;
      margin-bottom: 30px;
      animation: rotateDevice 2s ease-in-out infinite;
      color: #ffe066;
    }
    
    @keyframes rotateDevice {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    
    .orientation-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 20px;
      color: #ffe066;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .orientation-message {
      font-size: 18px;
      line-height: 1.6;
      margin-bottom: 30px;
      opacity: 0.9;
      max-width: 300px;
    }
    
    .fullscreen-btn {
      background: linear-gradient(135deg, #ffe066 0%, #ffcc00 100%);
      color: #1a1a2e;
      border: none;
      padding: 15px 30px;
      font-size: 16px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 20px;
      min-width: 200px;
      box-shadow: 0 4px 15px rgba(255, 224, 102, 0.3);
    }
    
    .fullscreen-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(255, 224, 102, 0.5);
    }
    
    .orientation-features {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
      opacity: 0.8;
    }
    
    .orientation-feature {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
    }
    
    .orientation-feature-icon {
      font-size: 18px;
      color: #4ecdc4;
    }
    
    #game {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Hide ALL desktop UI elements */
    #gameUI, #bottom-ui-panel, .game-ui-panel, #inventory-panel, #party-panel, #chat-container {
      display: none !important;
    }
    
    /* Mobile UI overlay */
    #mobile-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
    
    #mobile-overlay.active {
      display: block;
    }
    
    /* Top stats bar */
    #mobile-stats {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0.2));
      padding: 10px;
      padding-top: env(safe-area-inset-top, 10px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .stat-group {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 25px;
      font-size: 14px;
      color: white;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    .stat-icon {
      font-size: 18px;
    }
    
    #health-bar {
      width: 80px;
      height: 8px;
      background: rgba(255,255,255,0.3);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    #health-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ff8e53);
      transition: width 0.3s ease;
      width: 100%;
      border-radius: 3px;
    }
    
    /* Dual joystick system */
    .joystick-container {
      position: absolute;
      width: 140px;
      height: 140px;
      pointer-events: auto;
    }
    
    #movement-joystick {
      left: 20px;
      bottom: 20px;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    }
    
    #aim-joystick {
      right: 20px;
      bottom: 20px;
      bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
      border: 3px solid rgba(255,255,255,0.4);
      border-radius: 50%;
      box-shadow: 0 0 25px rgba(0,0,0,0.6), inset 0 0 20px rgba(255,255,255,0.1);
    }
    
    .joystick-stick {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.6));
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      pointer-events: none;
      border: 2px solid rgba(255,255,255,0.8);
    }
    
    /* Center action buttons */
    #center-actions {
      position: absolute;
      left: 50%;
      bottom: 40px;
      bottom: calc(40px + env(safe-area-inset-bottom, 0px));
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }
    
    .center-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      border: 3px solid;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .center-btn:active {
      transform: scale(0.9);
      box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    }
    
    #weapon-btn {
      background: rgba(255, 193, 7, 0.8);
      border-color: #ffc107;
      color: #fff;
    }
    
    #build-btn {
      background: rgba(40, 167, 69, 0.8);
      border-color: #28a745;
      color: white;
    }
    
    #build-btn.active {
      background: rgba(220, 53, 69, 0.8);
      border-color: #dc3545;
    }
    
    /* Build mode indicator */
    #build-mode-indicator {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 16px;
      border: 2px solid #dc3545;
      box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
      display: none;
      pointer-events: none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    /* Weapon interface */
    #weapon-interface {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      padding: 15px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 15px;
      border: 2px solid #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      pointer-events: auto;
      z-index: 1100;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
    }
    
    .weapon-grid {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .weapon-slot {
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .weapon-slot.selected {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }
    
    .weapon-slot.empty {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.2);
      cursor: default;
    }
    
    .weapon-slot img {
      width: 45px;
      height: 45px;
      object-fit: contain;
      image-rendering: pixelated;
    }
    
    .weapon-number {
      position: absolute;
      top: -5px;
      left: -5px;
      width: 20px;
      height: 20px;
      background: #333;
      border: 2px solid #ffd700;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #ffd700;
      font-weight: bold;
    }
    
    /* Build interface */
    #build-interface {
      position: absolute;
      bottom: 120px;
      right: 20px;
      display: none;
      flex-direction: column;
      gap: 10px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 15px;
      border: 2px solid #28a745;
      box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
      pointer-events: auto;
      z-index: 1100;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      max-height: 300px;
      overflow-y: auto;
    }
    
    .build-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    
    .build-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .build-slot.selected {
      background: rgba(255, 215, 0, 0.3);
      border-color: #ffd700;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .build-slot.delete {
      background: rgba(220, 53, 69, 0.7);
      border-color: #dc3545;
    }
    
    /* Quick actions */
    #quick-actions {
      position: absolute;
      top: 80px;
      right: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }
    
    .quick-btn {
      width: 50px;
      height: 50px;
      background: rgba(0,0,0,0.8);
      border: 2px solid rgba(255,255,255,0.4);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      color: white;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .quick-btn:active {
      background: rgba(255,255,255,0.2);
      transform: scale(0.95);
    }
    
    /* Landscape optimizations */
    @media screen and (orientation: landscape) {
      body {
        width: 100vw;
        height: 100vh;
      }
      
      #game canvas {
        width: 100vw !important;
        height: 100vh !important;
      }
      
      /* Adjust UI for landscape mode */
      #mobile-stats {
        padding: 8px 15px;
        padding-top: max(8px, env(safe-area-inset-top, 0px));
      }
      
      .stat-group {
        font-size: 13px;
        padding: 6px 12px;
      }
      
      /* Optimize joystick placement for landscape */
      .joystick-container {
        width: 130px;
        height: 130px;
      }
      
      #movement-joystick {
        left: max(15px, env(safe-area-inset-left, 0px));
        bottom: 15px;
      }
      
      #aim-joystick {
        right: max(15px, env(safe-area-inset-right, 0px));
        bottom: 15px;
      }
      
      /* Center buttons positioning */
      #center-actions {
        bottom: 25px;
      }
      
      .center-btn {
        width: 55px;
        height: 55px;
        font-size: 22px;
      }
      
      /* Quick actions positioning */
      #quick-actions {
        top: 70px;
        right: max(15px, env(safe-area-inset-right, 0px));
      }
      
      .quick-btn {
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      /* Build mode indicator */
      #build-mode-indicator {
        top: 70px;
        font-size: 15px;
        padding: 8px 16px;
      }
      
      /* Weapon and build interfaces */
      #weapon-interface {
        bottom: 110px;
        max-width: 400px;
      }
      
      #build-interface {
        bottom: 110px;
        right: max(15px, env(safe-area-inset-right, 0px));
        max-height: 200px;
      }
      
      .weapon-slot, .build-slot {
        width: 55px;
        height: 55px;
      }
      
      .weapon-slot img, .build-slot img {
        width: 40px;
        height: 40px;
      }
    }
    
    /* Responsive adjustments for small landscape screens */
    @media screen and (orientation: landscape) and (max-height: 500px) {
      #mobile-stats { 
        padding: 5px 10px; 
        padding-top: max(5px, env(safe-area-inset-top, 0px));
      }
      .stat-group { font-size: 11px; padding: 5px 8px; }
      .joystick-container { width: 110px; height: 110px; }
      .center-btn { width: 45px; height: 45px; font-size: 18px; }
      #center-actions { bottom: 15px; }
      #build-mode-indicator { top: 45px; font-size: 13px; padding: 6px 12px; }
      .quick-btn { width: 40px; height: 40px; font-size: 18px; }
      #weapon-interface { bottom: 85px; }
      #build-interface { bottom: 85px; max-height: 150px; }
    }
    
    /* iPhone X+ safe areas */
    @supports (padding: max(0px)) {
      #mobile-stats {
        padding-left: max(10px, env(safe-area-inset-left));
        padding-right: max(10px, env(safe-area-inset-right));
      }
      #movement-joystick { left: max(20px, env(safe-area-inset-left)); }
      #aim-joystick { right: max(20px, env(safe-area-inset-right)); }
      #quick-actions { right: max(15px, env(safe-area-inset-right)); }
      #build-interface { right: max(20px, env(safe-area-inset-right)); }
    }
  </style>
</head>
<body>
  <!-- Orientation prompt overlay -->
  <div id="orientation-overlay">
    <div class="rotate-icon">üì±</div>
    <h2 class="orientation-title">Rotate Your Device</h2>
    <p class="orientation-message">
      For the best Castle Wars experience, please rotate your device to landscape mode.
    </p>
    <button class="fullscreen-btn" onclick="enterFullscreen()">
      üéÆ Enter Fullscreen & Play
    </button>
    <div class="orientation-features">
      <div class="orientation-feature">
        <span class="orientation-feature-icon">üéØ</span>
        <span>Better aiming controls</span>
      </div>
      <div class="orientation-feature">
        <span class="orientation-feature-icon">üèóÔ∏è</span>
        <span>Easier building interface</span>
      </div>
      <div class="orientation-feature">
        <span class="orientation-feature-icon">üëÄ</span>
        <span>Wider field of view</span>
      </div>
    </div>
  </div>

  <div id="game"></div>
  
  <div id="mobile-overlay">
    <!-- Top stats bar -->
    <div id="mobile-stats">
      <div class="stat-group">
        <span class="stat-icon">‚ù§Ô∏è</span>
        <div id="health-bar">
          <div id="health-fill"></div>
        </div>
        <span id="health-text">100</span>
      </div>
      
      <div class="stat-group">
        <span class="stat-icon">üî´</span>
        <span id="weapon-name">PISTOL</span>
      </div>
      
      <div class="stat-group">
        <span class="stat-icon">üîµ</span>
        <span id="ammo-count">12/12</span>
      </div>
    </div>
    
    <!-- Build mode indicator -->
    <div id="build-mode-indicator">üèóÔ∏è BUILD MODE</div>
    
    <!-- Movement joystick -->
    <div id="movement-joystick" class="joystick-container">
      <div class="joystick-base"></div>
      <div class="joystick-stick"></div>
    </div>
    
    <!-- Aim joystick -->
    <div id="aim-joystick" class="joystick-container">
      <div class="joystick-base"></div>
      <div class="joystick-stick"></div>
    </div>
    
    <!-- Center action buttons -->
    <div id="center-actions">
      <div id="weapon-btn" class="center-btn">üî´</div>
      <div id="build-btn" class="center-btn">üèóÔ∏è</div>
    </div>
    
    <!-- Quick actions -->
    <div id="quick-actions">
      <div id="inventory-btn" class="quick-btn">üéí</div>
      <div id="chat-btn" class="quick-btn">üí¨</div>
    </div>
    
    <!-- Weapon interface -->
    <div id="weapon-interface">
      <div class="weapon-grid" id="weaponGrid">
        <!-- Weapons will be dynamically populated -->
      </div>
      <div style="text-align: center; margin-top: 10px;">
        <button id="delete-weapon-btn" style="background: rgba(220,53,69,0.7); border: none; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; margin-right: 10px; opacity: 0.5;" disabled>Delete</button>
        <button id="close-weapon-btn" style="background: rgba(40,167,69,0.7); border: none; color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px;">Close</button>
      </div>
    </div>
    
    <!-- Build interface -->
    <div id="build-interface">
      <div class="build-grid" id="buildGrid">
        <!-- Block slots will be dynamically populated -->
      </div>
    </div>
  </div>
  
  <script type="module">
    // Enhanced Mobile Controls with dual joysticks
    class EnhancedMobileControls {
      constructor() {
        this.movement = { x: 0, y: 0 };
        this.aiming = { x: 0, y: 0, angle: 0 };
        this.buildMode = false;
        this.selectedWeapon = 'pistol';
        this.selectedBlock = 'wall';
        this.deleteMode = false;
        this.weaponShopOpen = false;
        
        // Touch tracking for multi-touch
        this.activeTouches = new Map();
        this.maxJoystickDistance = 50;
        
        this.init();
      }
      
      init() {
        this.setupJoysticks();
        this.setupActionButtons();
        this.setupWeaponInterface();
        this.setupBuildInterface();
        this.setupQuickActions();
        this.startUpdateLoop();
      }
      
      setupJoysticks() {
        this.setupJoystick('movement-joystick', 'movement');
        this.setupJoystick('aim-joystick', 'aiming');
      }
      
      setupJoystick(containerId, type) {
        const container = document.getElementById(containerId);
        const stick = container.querySelector('.joystick-stick');
        
        const handleStart = (e) => {
          e.preventDefault();
          const touch = e.touches ? e.touches[0] : e;
          
          // Store this touch ID for this joystick
          const touchId = touch.identifier || 'mouse';
          if (this.activeTouches.has(touchId)) return;
          
          const rect = container.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          this.activeTouches.set(touchId, {
            joystick: type,
            startX: centerX,
            startY: centerY,
            container: container,
            stick: stick
          });
        };
        
        const handleMove = (e) => {
          e.preventDefault();
          
          // Handle all touches
          for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            const touchData = this.activeTouches.get(touch.identifier);
            
            if (!touchData || touchData.joystick !== type) continue;
            
            const rect = touchData.container.getBoundingClientRect();
          const currentX = touch.clientX - rect.left;
          const currentY = touch.clientY - rect.top;
          
            let deltaX = currentX - touchData.startX;
            let deltaY = currentY - touchData.startY;
          
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          
          if (distance > this.maxJoystickDistance) {
            const angle = Math.atan2(deltaY, deltaX);
            deltaX = Math.cos(angle) * this.maxJoystickDistance;
            deltaY = Math.sin(angle) * this.maxJoystickDistance;
          }
          
            touchData.stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            
            const normalizedX = deltaX / this.maxJoystickDistance;
            const normalizedY = deltaY / this.maxJoystickDistance;
            
            if (type === 'movement') {
              this.movement.x = normalizedX;
              this.movement.y = normalizedY;
            } else if (type === 'aiming') {
              this.aiming.x = normalizedX;
              this.aiming.y = normalizedY;
              if (distance > 10) { // Only update angle if moved significantly
                this.aiming.angle = Math.atan2(deltaY, deltaX);
              }
            }
          }
        };
        
        const handleEnd = (e) => {
          // Handle ended touches
          for (const changedTouch of e.changedTouches) {
            const touchData = this.activeTouches.get(changedTouch.identifier);
            if (touchData && touchData.joystick === type) {
              touchData.stick.style.transform = 'translate(0, 0)';
              
              if (type === 'movement') {
          this.movement = { x: 0, y: 0 };
              } else if (type === 'aiming') {
                this.aiming.x = 0;
                this.aiming.y = 0;
              }
              
              this.activeTouches.delete(changedTouch.identifier);
            }
          }
        };
        
        container.addEventListener('touchstart', handleStart, { passive: false });
        container.addEventListener('touchmove', handleMove, { passive: false });
        container.addEventListener('touchend', handleEnd, { passive: false });
        container.addEventListener('touchcancel', handleEnd, { passive: false });
      }
      
      setupActionButtons() {
        // Weapon button
        document.getElementById('weapon-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.toggleWeaponInterface();
        });
        
        // Build button
        document.getElementById('build-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.toggleBuildMode();
        });
      }
      
      setupWeaponInterface() {
        this.refreshWeaponInterface();
        
        // Close button listener
        document.getElementById('close-weapon-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.hideWeaponInterface();
        });
        
        // Delete weapon button listener
        document.getElementById('delete-weapon-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.deleteSelectedWeapon();
        });
      }
      
            refreshWeaponInterface() {
        const weaponGrid = document.getElementById('weaponGrid');
        weaponGrid.innerHTML = '';
        
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          const weapons = player.weaponTypes || [];
          
          // Update selectedWeapon to match current player weapon
          if (player.weapon && player.weapon.type) {
            this.selectedWeapon = player.weapon.type;
          } else if (player.currentWeaponType) {
            this.selectedWeapon = player.currentWeaponType;
          } else if (weapons.length > 0) {
            this.selectedWeapon = weapons[player.currentWeaponIndex || 0];
          }
          
          console.log(`Refreshing weapon interface. Player weapons:`, weapons);
          console.log(`Current selected weapon:`, this.selectedWeapon);
          
          // Show up to 5 weapon slots
          for (let i = 0; i < 5; i++) {
            const slot = document.createElement('div');
            slot.className = 'weapon-slot';
            slot.dataset.index = i;
            
            if (i < weapons.length) {
              const weaponType = weapons[i];
              const weaponSprite = this.getWeaponSprite(weaponType);
              
              // Check if this is the currently equipped weapon
              const isCurrentWeapon = (weaponType === this.selectedWeapon) || 
                                    (player.currentWeaponIndex === i) ||
                                    (player.weapon && player.weapon.type === weaponType);
              
              if (isCurrentWeapon) {
                slot.classList.add('selected');
                this.selectedWeapon = weaponType; // Update our selection
              }
              
              const img = document.createElement('img');
              img.src = `/assets/weapons/${weaponSprite}.png`;
              img.alt = weaponType;
              img.onerror = () => {
                slot.innerHTML = `<span style="font-size: 16px;">${weaponType.substr(0,3)}</span>`;
              };
              
              const number = document.createElement('div');
              number.className = 'weapon-number';
              number.textContent = (i + 1).toString();
              
              slot.appendChild(img);
              slot.appendChild(number);
              
              slot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.selectWeapon(weaponType, i);
                this.hideWeaponInterface();
              });
            } else {
              // Empty slot
              slot.classList.add('empty');
              slot.innerHTML = `<span style="font-size: 24px; color: rgba(255,255,255,0.3);">+</span>`;
              
              const number = document.createElement('div');
              number.className = 'weapon-number';
              number.textContent = (i + 1).toString();
              slot.appendChild(number);
            }
            
            weaponGrid.appendChild(slot);
          }
        }
      }
      
      getWeaponSprite(weaponType) {
        const spriteMap = {
          'pistol': 'Orange_pistol',
          'shotgun': 'shotgun',
          'rifle': 'rifle',
          'sniper': 'sniper',
          'tomatogun': 'tomatogun',
          'triangun': 'triangun',
          'minigun': 'minigun'
        };
        return spriteMap[weaponType] || 'pistol';
      }
      
      deleteSelectedWeapon() {
        if (this.selectedWeapon === 'pistol') {
          alert('Cannot delete the pistol!');
          return;
        }
        
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          const weapons = player.weaponTypes || [];
          const index = weapons.indexOf(this.selectedWeapon);
          
          if (index > 0) { // Don't delete pistol (index 0)
            weapons.splice(index, 1);
            if (player.weaponAmmo && player.weaponAmmo[this.selectedWeapon]) {
              delete player.weaponAmmo[this.selectedWeapon];
            }
            
            // Switch to pistol
            this.selectedWeapon = 'pistol';
            if (player.weapon) {
              player.weapon.type = 'pistol';
              player.currentWeapon = 0;
            }
            
            this.refreshWeaponInterface();
          }
        }
      }
      
      addWeaponFromShop(weaponType) {
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          const weapons = player.weaponTypes || [];
          
          // Check if weapon already exists
          if (weapons.includes(weaponType)) {
            this.selectedWeapon = weaponType;
            const existingIndex = weapons.indexOf(weaponType);
            this.selectWeapon(weaponType, existingIndex);
            return;
          }
          
          // Add weapon, replace 5th slot if full
          if (weapons.length >= 5) {
            // Replace the 5th weapon
            weapons[4] = weaponType;
            if (player.weaponAmmo && player.weaponAmmo[weapons[4]]) {
              delete player.weaponAmmo[weapons[4]];
            }
          } else {
            // Add to empty slot
            weapons.push(weaponType);
          }
          
          // Switch to new weapon
          this.selectedWeapon = weaponType;
          const newIndex = weapons.indexOf(weaponType);
          if (player.weapon) {
            player.weapon.type = weaponType;
            player.currentWeapon = newIndex;
          }
          
          // Send weapon switch to server
          if (window.gameScene.socket) {
            window.gameScene.socket.emit('weaponSwitch', {
              weaponType: weaponType,
              weaponIndex: newIndex
            });
          }
          
          this.refreshWeaponInterface();
        }
      }
      
      setupBuildInterface() {
        this.createBuildSlots();
      }
      
      createBuildSlots() {
        const buildGrid = document.getElementById('buildGrid');
        buildGrid.innerHTML = '';
        
        const blocks = [
          { type: 'wall', name: 'Wall', emoji: 'üß±' },
          { type: 'door', name: 'Door', emoji: 'üö™' },
          { type: 'tunnel', name: 'Tunnel', emoji: 'üöá' },
          { type: 'castle_tower', name: 'Castle Tower', emoji: 'üè∞' },
          { type: 'wood', name: 'Wood', emoji: 'ü™µ' },
          { type: 'gold', name: 'Gold', emoji: 'üèÜ' },
          { type: 'roof', name: 'Roof', emoji: 'üè†' },
          { type: 'brick', name: 'Brick', emoji: 'üß±' }
        ];
        
        blocks.forEach(block => {
          const slot = document.createElement('div');
          slot.className = 'build-slot';
          slot.dataset.type = block.type;
          
          const img = document.createElement('img');
          img.src = `/assets/blocks/${block.type}.png`;
          img.alt = block.name;
          img.style.width = '32px';
          img.style.height = '32px';
          img.style.imageRendering = 'pixelated';
          
          // Fallback to emoji if image fails to load
          img.onerror = () => {
            slot.innerHTML = `<span style="font-size: 24px;">${block.emoji}</span>`;
          };
          
          slot.appendChild(img);
          
          slot.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.selectBlock(block.type);
            this.deleteMode = false;
            const deleteSlot = document.querySelector('.build-slot.delete');
            if (deleteSlot) {
              deleteSlot.style.background = 'rgba(220, 53, 69, 0.7)';
            }
          });
          
          buildGrid.appendChild(slot);
        });
        
        // Add delete mode button
        const deleteSlot = document.createElement('div');
        deleteSlot.className = 'build-slot delete';
        deleteSlot.dataset.type = 'delete';
        deleteSlot.innerHTML = '‚ùå';
        
        deleteSlot.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.deleteMode = !this.deleteMode;
          deleteSlot.style.background = this.deleteMode ? 
            'rgba(220, 53, 69, 0.9)' : 'rgba(220, 53, 69, 0.7)';
          this.clearBlockSelection();
        });
        
        buildGrid.appendChild(deleteSlot);
      }
      
      setupQuickActions() {
        document.getElementById('inventory-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (window.gameScene && window.gameScene.inventoryUI) {
            window.gameScene.inventoryUI.toggle();
          }
        });
        
        document.getElementById('chat-btn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.showMobileChat();
        });
      }
      
      selectWeapon(weaponType, index) {
        this.selectedWeapon = weaponType;
        
        // Update visual selection
        document.querySelectorAll('.weapon-slot').forEach(slot => {
          slot.classList.remove('selected');
        });
        
        // Select the weapon slot
        const weaponSlots = document.querySelectorAll('.weapon-slot');
        if (weaponSlots[index]) {
          weaponSlots[index].classList.add('selected');
        }
        
        // Switch weapon in game
        if (window.gameScene && window.gameScene.playerSprite) {
          const player = window.gameScene.playerSprite;
          
          console.log(`Attempting to switch to weapon: ${weaponType} (index: ${index})`);
          console.log('Player weapon types:', player.weaponTypes);
          
          if (player.weaponTypes && player.weaponTypes.includes(weaponType)) {
            const weaponIndex = player.weaponTypes.indexOf(weaponType);
            console.log(`Found weapon at index: ${weaponIndex}`);
            
            if (weaponIndex !== -1) {
              // Use the proper weapon switching method
              if (player.switchWeapon) {
                player.switchWeapon(weaponIndex);
                console.log(`Successfully switched to weapon: ${weaponType}`);
              } else if (player.equipWeapon) {
                // Alternative method using equipWeapon
                player.equipWeapon(weaponType);
                player.currentWeaponIndex = weaponIndex;
                console.log(`Equipped weapon: ${weaponType}`);
              } else {
                // Fallback method
                player.currentWeapon = weaponIndex;
                player.currentWeaponIndex = weaponIndex;
                if (player.weapon) {
                  player.weapon.type = weaponType;
                }
                console.log(`Fallback weapon switch: ${weaponType}`);
              }
              
              // Send weapon switch to server
              if (window.gameScene.socket) {
                window.gameScene.socket.emit('weaponSwitch', {
                  weaponType: weaponType,
                  weaponIndex: weaponIndex
                });
              }
              
              // Also emit the changeWeapon event for compatibility
              if (window.gameScene.multiplayer && window.gameScene.multiplayer.socket) {
                window.gameScene.multiplayer.socket.emit('changeWeapon', weaponType);
              }
            }
          } else {
            console.warn(`Weapon ${weaponType} not found in player's weapon types:`, player.weaponTypes);
            
            // Try to add the weapon if it's missing (shouldn't happen but fail-safe)
            if (!player.weaponTypes) {
              player.weaponTypes = [];
            }
            
            if (!player.weaponTypes.includes(weaponType)) {
              player.weaponTypes.push(weaponType);
              console.log(`Added missing weapon ${weaponType} to player weapons`);
              
              // Now try to switch to it
              const newIndex = player.weaponTypes.indexOf(weaponType);
              if (player.switchWeapon) {
                player.switchWeapon(newIndex);
              } else if (player.equipWeapon) {
                player.equipWeapon(weaponType);
                player.currentWeaponIndex = newIndex;
              }
            }
          }
        }
        
        // Update display
        document.getElementById('weapon-name').textContent = weaponType.toUpperCase();
        
        // Update delete button
        const deleteBtn = document.getElementById('delete-weapon-btn');
        if (weaponType === 'pistol') {
          deleteBtn.disabled = true;
          deleteBtn.style.opacity = '0.5';
        } else {
          deleteBtn.disabled = false;
          deleteBtn.style.opacity = '1';
        }
      }
      
      selectBlock(blockType) {
        this.selectedBlock = blockType;
        this.deleteMode = false;
        
        // Update visual selection
        document.querySelectorAll('.build-slot').forEach(slot => {
          slot.classList.remove('selected');
        });
        
        const selectedSlot = document.querySelector(`[data-type="${blockType}"]`);
        if (selectedSlot) {
          selectedSlot.classList.add('selected');
        }
        
        // Set in game scene
        if (window.gameScene && window.gameScene.setSelectedBuilding) {
          window.gameScene.setSelectedBuilding(blockType);
        }
      }
      
      clearBlockSelection() {
        document.querySelectorAll('.build-slot').forEach(slot => {
          slot.classList.remove('selected');
        });
      }
      
      toggleWeaponInterface() {
        const weaponInterface = document.getElementById('weapon-interface');
        const buildInterface = document.getElementById('build-interface');
        
        if (weaponInterface.style.display === 'block') {
          this.hideWeaponInterface();
        } else {
          this.refreshWeaponInterface(); // Refresh when opening
          weaponInterface.style.display = 'block';
          buildInterface.style.display = 'none'; // Close build interface
        }
      }
      
      hideWeaponInterface() {
        document.getElementById('weapon-interface').style.display = 'none';
      }
      
      toggleBuildMode() {
        this.buildMode = !this.buildMode;
        
        const buildBtn = document.getElementById('build-btn');
        const buildInterface = document.getElementById('build-interface');
        const weaponInterface = document.getElementById('weapon-interface');
        const indicator = document.getElementById('build-mode-indicator');
        
        if (this.buildMode) {
          buildBtn.classList.add('active');
          buildBtn.innerHTML = '‚ùå';
          buildInterface.style.display = 'flex';
          weaponInterface.style.display = 'none'; // Close weapon interface
          indicator.style.display = 'block';
          this.selectBlock('wall'); // Default selection
        } else {
          buildBtn.classList.remove('active');
          buildBtn.innerHTML = 'üèóÔ∏è';
          buildInterface.style.display = 'none';
          indicator.style.display = 'none';
        }
        
        // Toggle build mode in game
        if (window.gameScene && window.gameScene.toggleBuildMode) {
          window.gameScene.toggleBuildMode();
        }
      }
      
      showMobileChat() {
        // Implementation for mobile chat (similar to previous version)
        console.log('Mobile chat not yet implemented');
      }
      
              startUpdateLoop() {
        setInterval(() => {
          if (window.gameScene && window.gameScene.playerSprite) {
            const player = window.gameScene.playerSprite;
            
            // Update health
            const healthPercent = Math.max(0, Math.min(100, (player.health / player.maxHealth) * 100));
            document.getElementById('health-fill').style.width = healthPercent + '%';
            document.getElementById('health-text').textContent = Math.ceil(player.health);
            
            // Update weapon display
            const weaponName = player.weapon ? player.weapon.type.toUpperCase() : 'FIST';
            document.getElementById('weapon-name').textContent = weaponName;
            
            // Update ammo
            let ammoDisplay = '‚àû';
            if (player.weapon && player.weapon.currentAmmo !== undefined && player.weapon.currentAmmo !== -1) {
              const current = player.weapon.currentAmmo;
              const max = player.weapon.magazineSize || 30;
              ammoDisplay = player.weapon.isReloading ? 'RELOAD' : `${current}/${max}`;
            }
            document.getElementById('ammo-count').textContent = ammoDisplay;
            
            // Check if in weapon shop
            this.checkWeaponShop(player);
          }
              }, 100);
            }
      
      checkWeaponShop(player) {
        // Weapon shop coordinates (same as desktop version)
        const shopX = 300;
        const shopY = 1650;
        const shopWidth = 400;
        const shopHeight = 400;
        
        if (player.x >= shopX && player.x <= shopX + shopWidth &&
            player.y >= shopY && player.y <= shopY + shopHeight) {
          
          if (!this.weaponShopOpen) {
            this.weaponShopOpen = true;
            this.showWeaponShop();
          }
        } else {
          if (this.weaponShopOpen) {
            this.weaponShopOpen = false;
            this.hideWeaponShop();
          }
        }
      }
      
      showWeaponShop() {
        // Create weapon shop overlay
        const shopOverlay = document.createElement('div');
        shopOverlay.id = 'weapon-shop-overlay';
        shopOverlay.style.position = 'absolute';
        shopOverlay.style.top = '50%';
        shopOverlay.style.left = '50%';
        shopOverlay.style.transform = 'translate(-50%, -50%)';
        shopOverlay.style.background = 'rgba(0, 0, 0, 0.95)';
        shopOverlay.style.border = '3px solid #ffd700';
        shopOverlay.style.borderRadius = '20px';
        shopOverlay.style.padding = '20px';
        shopOverlay.style.backdropFilter = 'blur(15px)';
        shopOverlay.style.zIndex = '2000';
        shopOverlay.style.color = 'white';
        shopOverlay.style.fontWeight = 'bold';
        shopOverlay.style.textAlign = 'center';
        
        const title = document.createElement('h3');
        title.textContent = 'üè™ WEAPON SHOP';
        title.style.color = '#ffd700';
        title.style.marginBottom = '20px';
        title.style.fontSize = '24px';
        shopOverlay.appendChild(title);
        
        const weaponList = [
          { type: 'shotgun', name: 'Shotgun', price: 1500 },
          { type: 'rifle', name: 'Rifle', price: 2000 },
          { type: 'sniper', name: 'Sniper', price: 3000 },
          { type: 'tomatogun', name: 'Tomato Gun', price: 2500 },
          { type: 'triangun', name: 'Triangun', price: 4000 },
          { type: 'minigun', name: 'Minigun', price: 5000 }
        ];
        
        weaponList.forEach(weapon => {
          const weaponBtn = document.createElement('button');
          weaponBtn.textContent = `${weapon.name} - ${weapon.price}ü™ô`;
          weaponBtn.style.display = 'block';
          weaponBtn.style.width = '100%';
          weaponBtn.style.padding = '10px';
          weaponBtn.style.margin = '5px 0';
          weaponBtn.style.background = 'rgba(255, 215, 0, 0.2)';
          weaponBtn.style.border = '2px solid #ffd700';
          weaponBtn.style.borderRadius = '10px';
          weaponBtn.style.color = 'white';
          weaponBtn.style.cursor = 'pointer';
          weaponBtn.style.fontSize = '16px';
          weaponBtn.style.fontWeight = 'bold';
          
          weaponBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.buyWeapon(weapon.type, weapon.price);
          });
          
          shopOverlay.appendChild(weaponBtn);
        });
        
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.marginTop = '20px';
        closeBtn.style.padding = '10px 20px';
        closeBtn.style.background = 'rgba(220, 53, 69, 0.7)';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '10px';
        closeBtn.style.color = 'white';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.fontSize = '16px';
        closeBtn.style.fontWeight = 'bold';
        
        closeBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.hideWeaponShop();
        });
        
        shopOverlay.appendChild(closeBtn);
        
        document.getElementById('mobile-overlay').appendChild(shopOverlay);
      }
      
      hideWeaponShop() {
        const shopOverlay = document.getElementById('weapon-shop-overlay');
        if (shopOverlay) {
          shopOverlay.remove();
        }
      }
      
      buyWeapon(weaponType, price) {
          if (window.gameScene && window.gameScene.playerSprite) {
            const player = window.gameScene.playerSprite;
            
          if (player.gold >= price) {
            player.gold -= price;
            this.addWeaponFromShop(weaponType);
            
            // Send purchase to server
            window.gameScene.socket.emit('weaponPurchase', {
              weapon: weaponType,
              cost: price
            });
            
            this.hideWeaponShop();
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.textContent = `Purchased ${weaponType.toUpperCase()}!`;
            successMsg.style.position = 'absolute';
            successMsg.style.top = '20px';
            successMsg.style.left = '50%';
            successMsg.style.transform = 'translateX(-50%)';
            successMsg.style.background = 'rgba(0, 255, 0, 0.8)';
            successMsg.style.color = 'white';
            successMsg.style.padding = '10px 20px';
            successMsg.style.borderRadius = '10px';
            successMsg.style.fontWeight = 'bold';
            successMsg.style.zIndex = '3000';
            
            document.getElementById('mobile-overlay').appendChild(successMsg);
            
            setTimeout(() => {
              successMsg.remove();
            }, 2000);
          } else {
            // Not enough gold
            alert(`Not enough gold! Need ${price} gold.`);
          }
        }
      }
    }
    
    // Fullscreen and orientation management
    window.enterFullscreen = function() {
      const element = document.documentElement;
      
      // Request fullscreen
      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
      
      // Try to lock orientation to landscape
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(() => {
          console.log('Orientation lock not supported or failed');
        });
      } else if (screen.lockOrientation) {
        screen.lockOrientation('landscape');
      } else if (screen.webkitLockOrientation) {
        screen.webkitLockOrientation('landscape');
      } else if (screen.mozLockOrientation) {
        screen.mozLockOrientation('landscape');
      }
      
      // Show success message briefly
      const btn = document.querySelector('.fullscreen-btn');
      const originalText = btn.innerHTML;
      btn.innerHTML = '‚úÖ Fullscreen Activated!';
      btn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
      
      setTimeout(() => {
        btn.innerHTML = originalText;
        btn.style.background = 'linear-gradient(135deg, #ffe066 0%, #ffcc00 100%)';
      }, 2000);
    };
    
    // Handle orientation changes
    let hasEnteredLandscape = false;
    
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        const isLandscape = window.orientation === 90 || window.orientation === -90;
        
        // Auto-trigger fullscreen hint when user rotates to landscape for first time
        if (isLandscape && !hasEnteredLandscape && !document.fullscreenElement) {
          hasEnteredLandscape = true;
          
          // Flash the fullscreen button to draw attention
          const btn = document.querySelector('.fullscreen-btn');
          if (btn && btn.offsetParent === null) { // Button is visible
            btn.style.animation = 'pulse 1s ease-in-out 3';
            
            // Show a subtle hint
            const hint = document.createElement('div');
            hint.textContent = 'üëÜ Tap for fullscreen experience!';
            hint.style.position = 'absolute';
            hint.style.bottom = '20px';
            hint.style.left = '50%';
            hint.style.transform = 'translateX(-50%)';
            hint.style.color = '#ffe066';
            hint.style.fontSize = '14px';
            hint.style.animation = 'fadeInOut 4s ease-in-out';
            
            document.getElementById('orientation-overlay').appendChild(hint);
            
            setTimeout(() => {
              if (hint.parentNode) {
                hint.remove();
              }
            }, 4000);
          }
        }
        
        // Resize game canvas if in landscape
        if (isLandscape) {
          if (window.gameScene && window.gameScene.scale) {
            window.gameScene.scale.refresh();
          }
        }
      }, 100);
    });
    
    // Add CSS animations for hints
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }
      
      @keyframes fadeInOut {
        0%, 100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
        20%, 80% { opacity: 1; transform: translateX(-50%) translateY(0); }
      }
    `;
    document.head.appendChild(style);
    
    // Handle fullscreen exit
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        console.log('Exited fullscreen');
      }
    });
    
    // Add wake lock to prevent screen from sleeping during gameplay
    let wakeLock = null;
    
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake lock active');
        }
      } catch (err) {
        console.log('Wake lock failed:', err);
      }
    }
    
    // Request wake lock when game starts
    document.addEventListener('touchstart', () => {
      if (!wakeLock) {
        requestWakeLock();
      }
    }, { once: true });
    
    // Initialize enhanced mobile controls
    window.mobileControls = new EnhancedMobileControls();
    
    // Import and setup the game
    import('./js/main.js').then(() => {
      console.log('Enhanced mobile game loaded');
      
      const waitForGame = setInterval(() => {
        if (window.GameScene) {
          clearInterval(waitForGame);
          
          // Override LoginScene
          if (window.LoginScene) {
            const originalLoginCreate = window.LoginScene.prototype.create;
            window.LoginScene.prototype.create = function() {
              originalLoginCreate.call(this);
              document.getElementById('mobile-overlay').classList.remove('active');
            };
          }
          
                    // Override GameScene create
          const originalCreate = window.GameScene.prototype.create;
          window.GameScene.prototype.create = function() {
            originalCreate.call(this);
            
            window.gameScene = this;
            document.getElementById('mobile-overlay').classList.add('active');
            
            // Enhanced mobile camera adjustments for landscape
            const gameSize = this.scale.gameSize;
            this.cameras.main.setViewport(0, 0, gameSize.width, gameSize.height);
            
            // Adjust zoom based on screen orientation and size
            const isLandscape = window.innerWidth > window.innerHeight;
            const screenRatio = window.innerWidth / window.innerHeight;
            
            if (isLandscape) {
              // Landscape mode - optimize for wider view
              if (screenRatio > 2) {
                // Very wide screens (like some phones)
                this.cameras.main.setZoom(0.7);
              } else if (screenRatio > 1.6) {
                // Standard landscape
                this.cameras.main.setZoom(0.8);
              } else {
                // Squarer landscape screens
                this.cameras.main.setZoom(0.9);
              }
            } else {
              // Portrait mode (should be rare due to our orientation lock)
              this.cameras.main.setZoom(1.0);
            }
            
            // Set camera bounds to world size
            this.cameras.main.setBounds(0, 0, 2400, 2400);
            
            // Enable camera following of player with smooth movement
            if (this.playerSprite) {
              this.cameras.main.startFollow(this.playerSprite, true, 0.1, 0.1);
              this.cameras.main.setDeadzone(100, 100);
            }
            
            // Hide desktop UI
            setTimeout(() => {
              const uiElements = document.querySelectorAll('#gameUI, .game-ui-panel, #bottom-ui-panel, .ui-panel');
              uiElements.forEach(el => el.style.display = 'none');
              
              const chatContainer = document.getElementById('chat-container');
              if (chatContainer) chatContainer.style.display = 'none';
              
              // Sync weapon interface with player weapons
              if (window.mobileControls) {
                setTimeout(() => {
                  window.mobileControls.refreshWeaponInterface();
                }, 1000);
                
                // Also refresh periodically to catch server updates
                setInterval(() => {
                  if (window.mobileControls && window.gameScene && window.gameScene.playerSprite) {
                    window.mobileControls.refreshWeaponInterface();
                  }
                }, 5000);
              }
              
              // Optimize performance for mobile
              this.physics.world.fps = 60;
              
              // Add orientation change handling
              window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                  const newIsLandscape = window.innerWidth > window.innerHeight;
                  const newScreenRatio = window.innerWidth / window.innerHeight;
                  
                  if (newIsLandscape) {
                    if (newScreenRatio > 2) {
                      this.cameras.main.setZoom(0.7);
                    } else if (newScreenRatio > 1.6) {
                      this.cameras.main.setZoom(0.8);
                    } else {
                      this.cameras.main.setZoom(0.9);
                    }
                  }
                  
                  // Refresh canvas size
                  this.scale.refresh();
                }, 200);
              });
              
            }, 100);
          };
          
          // Override update for enhanced mobile controls
          const originalUpdate = window.GameScene.prototype.update;
          window.GameScene.prototype.update = function(time, delta) {
            if (window.mobileControls) {
              const m = window.mobileControls.movement;
              const a = window.mobileControls.aiming;
              
              // Movement controls
              this.cursors.left.isDown = m.x < -0.3;
              this.cursors.right.isDown = m.x > 0.3;
              this.cursors.up.isDown = m.y < -0.3;
              this.cursors.down.isDown = m.y > 0.3;
              this.cursors.space.isDown = m.y < -0.7; // Jump on upward joystick
              
              // Aiming and shooting
              if (this.playerSprite && !this.playerSprite.isDead) {
                // Set aim angle from aim joystick
                if (Math.abs(a.x) > 0.1 || Math.abs(a.y) > 0.1) {
                  this.playerSprite.aimAngle = Phaser.Math.RadToDeg(a.angle);
                  
                  // ONLY shoot if not in build mode
                  if (!window.mobileControls.buildMode) {
                    this.playerSprite.isShooting = true;
                  } else {
                    this.playerSprite.isShooting = false;
                  }
                } else {
                  this.playerSprite.isShooting = false;
                }
                
                // FORCE disable shooting in build mode
                if (window.mobileControls.buildMode) {
                  this.playerSprite.isShooting = false;
                }
              }
            }
            
            originalUpdate.call(this, time, delta);
          };
        }
      }, 100);
    });
    
    // Prevent iOS bounce and handle multi-touch
    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    
    // Prevent context menu on long press
    document.body.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
  </script>
</body>
</html>